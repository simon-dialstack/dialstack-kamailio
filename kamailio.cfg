# kamailio/kamailio.cfg (full version with auth)
#!KAMAILIO

####### Global Parameters #########
# Log to stdout/stderr (12-factor app principle)
# Fluent Bit will ship logs to VictoriaLogs
log_stderror=yes
debug=2
memdbg=5
memlog=5

children=4
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Database URLs from environment (read/write split for multi-region)
# READ_DATABASE_URL: Local replica in each region (for auth queries)
# WRITE_DATABASE_URL: Primary database in us-east-1 (for location writes)
#!substdef "!READ_DB_URL!$(env(READ_DATABASE_URL))!g"
#!substdef "!WRITE_DB_URL!$(env(WRITE_DATABASE_URL))!g"

####### Modules Section ########
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "kex.so"
loadmodule "corex.so"

# Database modules
loadmodule "db_postgres.so"
loadmodule "sqlops.so"

# Authentication and registration
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"

# NAT traversal
loadmodule "nathelper.so"

####### Module Parameters ########

# ----- usrloc params -----
# Writes registration location to PRIMARY database
modparam("usrloc", "db_url", "WRITE_DB_URL")
modparam("usrloc", "db_mode", 2)  # Write-through mode
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", 7)  # NAT branch flag (must match nathelper)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 300)    # 5 minutes - NAT keepalives handle connectivity
modparam("registrar", "min_expires", 60)     # 1 minute minimum
modparam("registrar", "default_expires", 300)

# ----- auth_db params -----
# Reads from READ database (local replica for better performance)
modparam("auth_db", "db_url", "READ_DB_URL")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "sip_password")
modparam("auth_db", "user_column", "sip_username")
modparam("auth_db", "domain_column", "sip_realm")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 20)  # Send pings every 20 seconds
modparam("nathelper", "ping_nated_only", 1)    # Only ping NAT endpoints
modparam("nathelper", "sipping_bflag", 7)      # bflag for NAT detection
modparam("nathelper", "sipping_from", "sip:keepalive@dialstack.ai")

####### Routing Logic ########

request_route {
    # Basic sanity checks
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Log all requests
    xlog("L_INFO", "Request: $rm from $fu ($si:$sp) to $ru\n");

    # Reply to OPTIONS
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTER);
        exit;
    }

    # Everything else gets 404
    sl_send_reply("404", "Not Found");
}

# NAT detection
route[NAT_DETECT] {
    force_rport();

    # Test if behind NAT (RFC3581 rport + received check)
    if (nat_uac_test("19")) {
        setbflag(7);  # Mark as NAT endpoint
        xlog("L_INFO", "NAT detected for $fu from $si:$sp (received=$Ri:$Rp)\n");
    }
}

# REGISTER processing
route[REGISTER] {
    # NAT detection
    route(NAT_DETECT);

    # Challenge without credentials
    if (!is_present_hf("Authorization")) {
        auth_challenge("$fd", "0");
        exit;
    }

    # Authenticate against endpoints table (reads from READ_DB_URL)
    if (!auth_check("$fd", "endpoints", "1")) {
        auth_challenge("$fd", "0");
        exit;
    }

    # Fix contact for NAT
    if (isbflagset(7)) {
        fix_nated_contact();
    }

    # Save location (writes to WRITE_DB_URL)
    if (!save("location")) {
        sl_reply_error();
        exit;
    }

    xlog("L_INFO", "Registration successful for $fu (NAT: $bf)\n");
}
